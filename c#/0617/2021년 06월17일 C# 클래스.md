## 2021년 06월17일 C# 클래스  
## 클래스  
```
C# 프로그램 구성 기본 단위 
재 사용성, 이식성, 유연성 증가 
객체를 정의하는 탬플릿 - 객체의 구조와 행위를 정의하는 방법
자료 추상화의 방법 
```
## 객체  
```
유형적(사물), 무형적인(개념, 논리) 것들 
프로그래밍에서의 객체는 클래스에 정의된 내용이 메모리에 생성된 것
```
## 학습 목표  
```
1. 클래스와 객체를 이해하고 설명할 수 있다. 
2. 필드, 메소드, 프로퍼티를 이해하고 구현할 수 있다.
3. 인덱서, 델리게이트, 이벤트를 이해하고 구현할 수 있다. 
4. 연산자 중복과 구조체를 이해하고 구현할 수 있다.
```
## 클래스  
```
1. C# 프로그래밍의 기본단위 - 재사용성, 이식성, 유연성 증가 
2. 객체를 정의하는 탬플릿 - 객체의 구조와 행위를 정의하는 방법
3. 자료 추상화의 방법 
```
## 클래스의 구조  
```
속성: 필드
행위: 메소드 
이외에 상수와 프로퍼티, 인덱서, 연산자 중복, 이벤트 클래스형이나 
델리게이트형과 같은 자료형이 클래스 안에 포함 될 수 있음
```
![image-20210616222112519](2021년 06월17일 C# 클래스.assets/image-20210616222112519.png)
## 수정자(Modifier)  
```
부가적인 속성을 명시하는 방법 
```
![image-20210616222159177](2021년 06월17일 C# 클래스.assets/image-20210616222159177.png)
## 클래스형의 변수 선언  
```
객체를 선언하는 방법 : 클래스 이름을 쓰고 그에 해당하는 객체들을 나열 
Fraction f1, f2;
이렇게 객체를 참조하는 변수 선언 참조 변수 
```
## 객체를 생성하는 방법  
```
new 연산자와 함께 생성자를 명시하는 형태로 기술  
f1 = new Fraction();
Fracton f1 = new Fraction();
```
## 생성자  
```
- 객체를 생성할 때 객체의 초기화를 위해 자동으로 호출되는 루틴
- 클래스와 동일한 이름을 갖는 메소드 
- 객체 생성 시에 필요한 초기 값을 매개변수로 가질 수 있음
```
## 객체 이름과 멤버 사이에 멤버  접근 연산자인  점연산자 사용  
```
예) 
필드 참조: f1.numerator 
메소드 참조: f1.Add(f2)

멤버의 참조 형태:
objectName.MemberName
```
## 필드, 메소드, 프로퍼티  
## 필드  
```
클래스의 형태에서 객체의 구조를 기술하는 자료 부분 
변수들의 선언으로 구성 
```
## 필드 선언 형태   
```
[field-modifier] DataType fieldnames;
```
![image-20210616223336146](2021년 06월17일 C# 클래스.assets/image-20210616223336146.png)
## 접근 수정자   
```
다른 클래스에서 필드의 접근 허용 정도를 나타내는 속성 
```
![image-20210616223419176](2021년 06월17일 C# 클래스.assets/image-20210616223419176.png)
## private  
```
- 정의된 클래스 내에서만 필드 접근 허용 
- 접근 수정자가 생략된 경우 
```
## public  
```
모든 클래스 및 네임스페이스에서 자유롭게 접근  
```
## internal  
```
같은 네임스페이스 내에서 자유롭게 접근
```
## protected  
```
파생 클래스에서만 참조 가능
```
## protected inernal 혹은 internal protected  
```
파생 클래스와 동일 네임스페이스 내에서도 자유롭게 접근
```
## new  
```
상속 계층에서 상위 클래스에서 선언된 멤버를 하위 클래스에서 새롭게 재정의 하기 위해
사용 
```
## static  
```
- 정적 필드 
- 클래스 단위로 존재
- 생성 객체가 없는 경우에도 존재하는 변수  
- 정적 필드의 참조 형태 
ClassName.staticField
```
## readonly  
```
- 읽기 전용 필드 
- 값이 변할 수 없는 속성 
- 실행 중에 값에 값이 결정
```
## const  
```
- 값이 변할 수 없는 속성  
- 컴파일 시간에 값이 결정
- 상수 멤버의 선언 형태
[const-modifiers] const DataType constNames;
```
## 메소드  
```
객체의 행위를 기술하는 방법  
- 객체의 상태를 검색하고 변경하는 작업  
- 특정한 행동을 처리하고 프로그램 코드를 포함하고 있는 함수의 형태 
```
![image-20210616224141859](2021년 06월17일 C# 클래스.assets/image-20210616224141859.png)
## 메소드 수정자  
```
매소드 수정자는 총 11개 있고 
접근 수정자는 public, protected, internal, private 가있다.
```
## static  
```
- 정적 메소드  
- 전역 함수와 같은 역할
- 정적 메소드는 해당 클래스의 정적 필드 또는 정적 메소드만 참조 가능
- 정적 메소드 호출 형태 객체의 상태를 검색하고 변경하는 작업 
- 특정한 행동을 처리하는 프로그램 코드를 포함하고 있는 함수의 형태 
ClassName.MethodName();
```
## abstract/ extern  
```
메소드 몸체 대신에 세미콜론; 이 나옴
abstract: 메소드가 하위 클래스에 정의 
extern: 메소드가 외부에 정의 
```
## 이 외의 메소드 수정자  
```
new, virtual, override, sealed 
```
##  매개 변수  
```
메소드 내에서만 참조될 수 있는 지역변수 

- 형식 매개변수(foraml parameter)
: 메소드를 정의할 때, 사용하는 매개변수 
- 실 매개변수(actual parameter)
: 메소드를 호출할 때 사용하는 매개 변수 
```
## 매개변수의 자료형  
```
기본형과 참조형이 있다. 
ex)
void parameterPass(int i, Fraction f){
 //todo sth...
}
```
## this 지정어  
```
자기 자신의 객체를 가리키는 포인터 특별한 포인터 
클래스 필드와 매개변수를 구별하기 위함 
```
![image-20210616225136226](2021년 06월17일 C# 클래스.assets/image-20210616225136226.png)
```
메소드 안에서 사용되는 모든 필드와 메소드 이름 앞에는 내부적으로 this가 붙어 있음
```
## 매개변수 전달  
```
메소드 호출 시에 실 매개변수가 형식 매개변수로 전달 되는 것  
전달된 실 매개변수가 호출된 매소드 내에서 사용 
```
## C#에서의 매개변수 전달 방법  
```
1. 값 호출 (Call by value) 
- 실 매개변수의 값이 형식 매개변수로 전달 
2. 참조 호출 (Call by reference)
- 주소 호출 
- 실 매개변수의 주소가 형식 매개변수로 전달 
- C# 에서 제공하는 방법 
  매개 변수 수정자 이용
  ,객체 참조를 매개변수로 사용 
```
## 매개변수 수정자  
```
ref: 매개변수가 전달될 때 반드시 초기화 
out: 매개변수가 전달될 때 초기화하지 않아도 됨 
```
## 매개변수 배열  
```
- 실 매개변수의 개수가 상황에 따라 가변적인 경우 
- 매소드를 정의할 때 형식 매개변수를 결정할 수 없음
```
![image-20210616230443356](2021년 06월17일 C# 클래스.assets/image-20210616230443356.png)
![image-20210616230501499](2021년 06월17일 C# 클래스.assets/image-20210616230501499.png)
## C# 응용 프로그램의 시작점  
```
Main 메소드의 기본 형태 
public static void Main(string[] args){
//...
}
- 매개변수 : 명령어 라인으로부터 스트링 전달 
- 명령어 라인으로부터 스트링 전달 방법 
c:\> 실행파일명 인수1 인수2 ... 인수n
- args[0]= 인수1, args[1]= 인수2, args[n-1]= 인수n
```
## 시그니처(Signature)  
```
메소드를 구별하는데 쓰이는 정보 
메소드이름, 매개변수의 개수, 매개변수의 자료형, 메소드 반환형 제외
```
## 매소드 중복  
```
메소드의 이름은 같은데 매개변수의 개수와 형이 다른 경우
호출시 컴파일러에 의해 메소드 구별

void SameNameMethod(int i){}
void SameNameMethod(int i, int j){}
```
![image-20210616231019931](2021년 06월17일 C# 클래스.assets/image-20210616231019931.png)
## 생성자  
```
객처가 생성될 때 자동으로 호출되는 메소드 
클래스 이름과 동일하며 반환형을 갖지 않음
주로 객체를 초기화하는 작업에 사용 
생성자 중복 가능
```
![image-20210616231141699](2021년 06월17일 C# 클래스.assets/image-20210616231141699.png)
## 정적 생성자 (Static constructor)  
```
수정자가 static으로 선언된 생성자 
매개변수와 접근 수정자를 가질 수 없음
클래스의 정적 필드를 초기화 할 때 사용
Main() 매소드보다 먼저 실행
```
## 정적 필드 초기화 방법  
```
- 정적 필드 선언과 동시에 초기화 
- 정적 생성자 이용 
```
![image-20210616231339512](2021년 06월17일 C# 클래스.assets/image-20210616231339512.png)
## 소멸자  
```
클래스의 객체가 소멸될 때 필요한 행위를 기술한 매소드 
소멸자의 이름은 생성자와 동일하나 이름 앞에 
~ (tilde)를 붙임
```
## Finalize() 메소드  
```
- 컴파일 시 소멸자를 Finalize() 메소드로 변환해서 컴파일
- Finalize() 메소드 재정의할 수 없음
- 객체가 더 이상 참조되지 않을 때 GC(Garbage Collection)에 의해 호출
```
## Dispose()메소드  
```
CLR에서 관리되지 않은 자원을 직접 해제할 때 사용 
자원이 스코프를 벗어나면 즉시 시스템에 의해 호출
```
## 프로퍼티란?  
```
클래스의 private 필드를 형식적으로 다루는 일종의 메소드
셋-접근자 : 값을 지정
겟-접근자 : 값을 참조
겟-접근자 혹은 셋 : 접근자만 정의할 수 있음
```
![image-20210616231859448](2021년 06월17일 C# 클래스.assets/image-20210616231859448.png)
```
프로퍼티 수정자
수정자의 종류와 의미는 메소드와 모두 동일
```
![image-20210616232002711](2021년 06월17일 C# 클래스.assets/image-20210616232002711.png)
## 프로퍼티의 동작   
```
- 필드처럼 사용되지만, 메소드처럼 동작  
- 배정문의 왼쪽에서 사용되면 셋- 접근자 호출
- 배정문의 오른쪽에서 사용되면 겟- 접근자 호출
```
![image-20210616232123165](2021년 06월17일 C# 클래스.assets/image-20210616232123165.png)
## 인덱서  
```
배열 연산자인 []를 통해서 객체를 다룰 수 있도록함 
지정어 this를 사용하고, []안에 인덱스로 사용되는 매개 변수 선어 
겟-접근자 혹은 셋-접근자만 정의할 수 있음
```
## 인덱서의 수정자  
```
- static만 사용할 수 없으며, 의미는 메소드와 모두 같음
```
![image-20210617161933454](2021년 06월17일 C# 클래스.assets/image-20210617161933454.png)
```
[indexer-modifiers] returnType this[parameterList]{
	set{
		//indexer body
	}
	get{
		//indexer bodys
	}
}
```
![image-20210617162015624](2021년 06월17일 C# 클래스.assets/image-20210617162015624.png)
## 델리게이트(Delegate)  
```
메소드 참조 기법 : 객체 지향적 특징이 반영된 메소드 포인터 
이벤트와 스레드를 처리하기 위한 방법론
```
## 특징  
```
1. 객체지향적: 정적메소드 및 인스턴트 메소드 참조 가능
2. 타입안정적: 델리게이트의 형태와 참조하고자하는 메소드의 형태는 항상 일치
3. 메소드참조: 델리게이트 객체를 통하여 메소드를 호출

[함수포인터 C/C++]
1. 메소드 참조 기법면에서 유사
2. 객체지향적이며 타입 안정적

정의 형태:
[modifiers] delegate returnType DelegateName(paramerList);
```
## 델리게이트 정의 시 주의점  
```
델리게이트 할 메소드의 메소드 반환형 및 매개변수의 개수,
반환형을 일치시켜야함 

delegate void SampleDelegate(int param);// 델리게이트 정의
class DelegateClass{
	public void DelegateMethod(int param){//델리게이트 메소드
	 //...
	}
}

델리게이트를 사용하기 위해서는 델리게이트 객체를 생성하고 대상 메소드를 연결해야 함 
- 해당 델리게이트의 매개변수로 메소드의 이름을 명시
- 델리게이트 객체에 연결할 수 있는 메소드는 형태가 동일하면 
인스턴스 메소드뿐만 정적 메소드도 가능
```
## 델리게이트 생성 (인스턴스 메소드)  
```
1. 델리게이트할 메소드가 포함된 클래스의 객체를 먼저 생성
2. 정의된 델리게이트 형식으로 델리게이트 객체를 생성
3. 생성된 델리게이트를 통하여 연결된 메소드의 호출

DelegateClass obj = new DelegateClass();
SampleDelegate sd = new SampleDelegate(obj.DelegateMethod);
```
## 델리게이트 객체 호출  
```
1. 델리게이트 객체의 호출은 일반 메소드의 호출과 동일 
2. 델리게이트를 통하여 호출할 메소드가 매개변수를 갖는다면
델리게이트를 호출하면서()안에 매개변수를 기술
```
![image-20210617163701180](2021년 06월17일 C# 클래스.assets/image-20210617163701180.png)
## 멀티캐스트  
```
하나의 델리게이트 객체에 형태가 동일한 여러 개의 메소드를 연결하여 사용가능
C#언어는 델리게이트를 위한 +와 -연산자(메소드 추가/제거)를 제공

* 멀티캐스트 델리게이션
- 델리게이트 연산을 통해 하나의 델리게이트 객체에 여러 개의 메소드가 연결돼 있는 경우
- 델리게이트 호출을 통해 연결된 모든 메소드를 한번에 호출
- 델리게이트를 통하여 호출되는 순서는 등록된 순서와 동일
```
![image-20210617164052817](2021년 06월17일 C# 클래스.assets/image-20210617164052817.png)
## 이벤트  
```
- 사용자 행동에 의해 발생하는 사건
- 어떤 사건이 발생한 것을 알리기 위해 보내는 메시지
- C#에서는 이벤트 개념을 프로그래밍 언어 수준에서 지원

이벤트 처리기(event handler)
:발생한 이벤트를 처리하기 위한 메소드 

형식:
[event-modifier] event DelegateType EventName;
```
## 이벤트 주도 프로그래밍  
```
- 이벤트와 이벤트 처리기를 통하여 객체에 발생한 사건을 다른 객체에 통지하고
그에 대한 행위를 처리하도록 시키는 구조를 가짐
- 각 이벤트에 따른 작업을 독립적으로 기술 
- 프로그램의 구조가 체계적/ 구조적이며 복잡도를 줄일 수 있음
```
## 이벤트 정의 순서  
```
이벤트 처리기의 형태와 일치하는 델리게이트를 정의 (또는 System.EventHandler)
델리게이트를 사용 

델리게이트를 이용하여 이벤트를 선언(미리 정의된 이벤트인 경우에는 생략)

이벤트 처리기를 작성

이벤트에 이벤트 처리기를 등록

이벤트를 발생(미리 정의된 이벤트는 사용자가 행동에 의해 이벤트가 발생)

-> 이벤트가 발생되면 등록된 메소드가 호출되어 이벤트를 처리 
(미리 정의된 이벤트 발생은 사용자의 행동에 의해서 발생)
(사용자 정의 이벤트인 경우에는 명시적으로 델리게이트 객체를 호출함으로써
이벤트 처리기를 작동)
```
![image-20210617164751064](2021년 06월17일 C# 클래스.assets/image-20210617164751064.png)![image-20210617164909124](2021년 06월17일 C# 클래스.assets/image-20210617164909124.png)
## 이벤트 처리기 등록  
```
- 델리게이트 객체에 메소드를 추가/ 삭제하는 방법과 동일 
- 사용연산자 
Event = new DelegateType(Method);// = : 이벤트 처리기 등록,
Event += new DelegateType(Method);// + : 이벤트 처리기 추가,
Event -= new DelegateType(Method);// - : 이벤트 처리기 제거
```
##  C#언어에서의 이벤트 사용  
```
- 프로그래머가 임의의 형식으로 델리게이트를 정의하고 이벤트를 선언할 수 있음
- .NET 프레임워크는 이미 정의된 System.EventHandler 델리게이트를 
이벤트에 사용하는 것을 권고
- System.EventHandler
선언 형태:
delegate void EventHandler(object sender, EventArgs e);
```
## 이벤트와 윈도우 환경  
```
- 이벤트는 사용자와 상호작용을 튀해 주로 사용
- 윈도우 프로그래밍 환경에서 사용하는 폼과 수많은 컴포넌트와 컨트롤에는
다양한 종류와 이벤트가 존재  
- 프로그래머로 하여금 적절히 사용할 수 있도록 방법론을 제공 
```
## 연산자 중복과 구조체  
```
시스템에서 제공한 연산자를 재정의 하는 것 
+, - , =을 재정의 하는것 

클래스만을 위한 연산자로서 자료 추상화가 가능
문법적인 규칙은 변경 불가(연산 순위나 결함 법칙 등)
```
![image-20210617165656327](2021년 06월17일 C# 클래스.assets/image-20210617165656327.png)
## 연산자 중복 방법  
```
수정자는 반드시 public static
반환형은 연산자가 계산된 결과의 자료형
지정어 operator 사용, 연산기호로는 특수 문자 사용
```
![image-20210617165813067](2021년 06월17일 C# 클래스.assets/image-20210617165813067.png)
![image-20210617165825005](2021년 06월17일 C# 클래스.assets/image-20210617165825005.png)
## 대칭적 방식으로 정의  
```
true <-> false, == <-> !=, < <-> >, <= <-> >= 
```
## 형변환 연산자  
```
클래스 객체나 구조체를 다른 클래스나 구조체 또는 C# 기본 자료형으로 변환 
사용자 정의형 변환

문법 구조:
public static[extern] explicit operator type-name(parameter1)
public static[extern] implicit operator type-name(parameter1)
```
![image-20210617170118965](2021년 06월17일 C# 클래스.assets/image-20210617170118965.png)
## 구조체  
```
클래스와 동일하게 객체의 구조와 행위를 정의하는 방법 

클래스: 참조형
구조체: 값형

형태:
[struct-modifiers] struct StructName{
}
```
## 구조체와 클래스의 차이점  
```
1. 클래스는 참조형이고 구조체는 값형이다.
2. 클래스 객체는 힙에 저장되고 구조체 객체는 스택에 저장된다. 
3. 배정연산에서 클래스는 참조가 복사되고 구조체는 내용이 복사된다.
4. 구조체는 상속이 불가능하다.
5. 구조체는 소멸자를 가질 수 없다.
6. 구조체의 맴버는 초기값을 가질 수 없다.
```
## 복습   
```
모든 메소드는 시그너처를 가지고 있다.
시그너처란 메소드를 구별하는데 쓰이는 정보로
메소드의 이름, 매게변수의 개수, 그리고 매개변수들의 자료형을 의미
```
## 클래스와 객체   
```
C#의 클래스는 C#프로그램을 구성하는 기본단위이며 구조를 나타내는 필드와 행위를 
나타내는 메소드로 구성됨

일단 클래스가 정의되면 그 클래스로부터 갤체를 선언할 수 있으며 객체를 선언하는
방법은 클래스 이름을 쓰고 그에 해댱하는 객체들을 나열함
```
## 필드, 매소드, 프로퍼티  
```
클래스의 형태에서 객체의 구조를 기술하는 자료 부분은 변수들의 선언으로 구성되며,
각각의 클래스의 필드라고 부름

메소드란 객체의 행위를 기술하는 방법으로 객체의 상태를 검색하고 변경하는 작업,
그리고 특정한 행동을 처리하는 프로그램 코드를 포함하고 있는 함수의 형태

프로퍼티란 클래스의 private필드를 형식적으로 다루는 일종의 메소드로 간주
```
## 인덱서, 델리게이트, 이벤트  
```
인덱서란 배열의 연산자인 []를 통해서 객체를 다룰 수 있도록 해주는 특별한 
형태의 프로퍼티임

델리게이트는 메소드를 참조하기 위한 기법으로 이벤트와 스레드를 처리하는데 주로 사용됨

이벤트란 사용자 행동에 의해 발생하는 사건을 의미하며 어떤 사건이 발생한 것을 알리기 
위해 보내는 메시지로 간주함
```
## 연산자 중복과 구조체  
```
연산자 중복이란 시스텐세서 제공한 연산자를 특정 클래스만 위한 연산 의미를 
갖도록 재정의함

구조체란 클래스와 동일하게 객체의 구조와 행위를 정의하는 방법이며
클래스와의 차이점은 클래스는 참조형이고 구조체는 값형임
```